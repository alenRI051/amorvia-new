import { track, scenarioStart, choiceMade, lineNext, actEnd, saveSlot, loadSlot } from './metrics.js';
function readMeters(engine){ const m=engine?.meters||engine?.state?.meters||null; if(!m) return null; const out={}; for(const k of Object.keys(m)){ const v= typeof m[k]==='number'? m[k] : (m[k]?.value ?? m[k]?.current ?? null); if (typeof v==='number') out[k]=v; } return out; }
function diffMeters(a,b){ const d={}; if(!a||!b) return d; for(const k of Object.keys({...a,...b})){ const av=a[k], bv=b[k]; if(typeof av==='number' && typeof bv==='number') d[k]=bv-av; } return d; }
function snap(engine){ return { scenarioId:engine?.currentScenarioId||engine?.state?.scenario?.id||engine?.scenario?.id, actId:engine?.currentActId||engine?.state?.act?.id||engine?.act?.id, nodeId:engine?.currentNodeId||engine?.state?.node?.id||engine?.node?.id, nodeType:engine?.state?.node?.type||engine?.node?.type }; }
function guessChoice(args){ let index, label; for(const a of args){ if(index==null && typeof a==='number') index=a; if(label==null && typeof a==='string') label=a; if(a&&typeof a==='object'){ if(index==null && typeof a.index==='number') index=a.index; if(label==null && typeof a.label==='string') label=a.label; } } return { index, label }; }
function wrap(obj,name,before,after){ const fn=obj && obj[name]; if(typeof fn!=='function') return false; obj[name]=function(...args){ let pre; try{ pre= before? before(this,args): undefined;}catch{} const ret = fn.apply(this,args); try{ if(after) after(this,args,pre,ret);}catch{} return ret; }; return true; }
export function attachMetrics(engine){ if(!engine) return; const startHook=(self,args)=>{ const id=args?.[0]||snap(self).scenarioId; if(id) scenarioStart(id); };
  wrap(engine,'loadScenario',null,startHook) || wrap(engine,'startScenario',null,startHook);
  wrap(engine,'saveSlot',(self,args)=>{try{saveSlot(args?.[0]);}catch{}},null);
  wrap(engine,'loadSlot',(self,args)=>{try{loadSlot(args?.[0]);}catch{}},null);
  for (const nm of ['choose','makeChoice','applyChoice','onChoice']){ const ok = wrap(engine,nm,(self,args)=>({pre:snap(self),meters:readMeters(self),choice:guessChoice(args)}),(self,args,state)=>{ const cur=snap(self); const s=state?.pre||cur; choiceMade(s.scenarioId,s.actId,s.nodeId,state?.choice?.index,state?.choice?.label); if(s.nodeId) lineNext(s.scenarioId,s.actId,s.nodeId); if(!cur.nodeId || cur.nodeType==='end'){ const deltas=diffMeters(state?.meters,readMeters(self)); actEnd(s.scenarioId,s.actId,deltas);} }); if(ok) break; }
  for (const nm of ['advance','goNext','next','continue']){ wrap(engine,nm,(self)=>({pre:snap(self),meters:readMeters(self)}),(self,args,state)=>{ const prev=state?.pre; if(prev?.nodeId) lineNext(prev.scenarioId,prev.actId,prev.nodeId); const cur=snap(self); if(!cur.nodeId || cur.nodeType==='end'){ const deltas=diffMeters(state?.meters,readMeters(self)); actEnd(prev.scenarioId,prev.actId,deltas); } }); }
  wrap(engine,'endAct',(self)=>({pre:snap(self),meters:readMeters(self)}),(self,args,state)=>{ const s=state?.pre||snap(self); const deltas=diffMeters(state?.meters,readMeters(self)); actEnd(s.scenarioId,s.actId,deltas); });
  try{ track('app_init'); }catch{} return engine; }
try{ if(typeof window!=='undefined'){ const g=window; const candidate=g.AmorviaEngine||g.engine||g.AppEngine||null; if(candidate) attachMetrics(candidate); } }catch{}