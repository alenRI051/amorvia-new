<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Amorvia — Logs Admin</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>
<body>
  <header>
    <h1>Amorvia — <span class="muted">Logs Admin</span></h1>
    <p class="muted">Browse and export Blob-stored events.
      <a href="/admin/help.html" style="margin-left:12px;">Help</a>
    </p>
  </header>

  <main>
    <section class="controls">
      <label>Date
        <input id="date" type="date"/>
      </label>

      <label>Admin Token (optional)
        <input id="token" type="password" placeholder="ADMIN_TOKEN if enabled"/>
      </label>

      <div class="actions">
        <button id="btnList">List Logs</button>
        <button id="btnExportJsonl">Export JSONL</button>
        <button id="btnExportCsv">Export CSV</button>
        <button id="btnToday" class="secondary">Today</button>
      </div>

      <!-- Retention / Prune -->
      <fieldset style="display:flex;gap:12px;align-items:end;flex-wrap:wrap;border:1px solid #1e293b;padding:8px 10px;border-radius:12px">
        <legend class="muted" style="padding:0 6px">Retention</legend>
        <label>Keep last (days)
          <input id="pruneDays" type="number" min="1" value="30" />
        </label>
        <label style="display:flex;align-items:center;gap:6px">
          <input id="pruneDry" type="checkbox" checked /> Dry run
        </label>
        <div class="actions">
          <button id="btnPruneDry" class="secondary" type="button">Preview</button>
          <button id="btnPruneGo"  type="button">Prune</button>
        </div>
      </fieldset>
    </section>

    <section id="status" class="status" aria-live="polite"></section>

    <section class="results">
      <div class="row">
        <h2>Items</h2>
        <div class="spacer"></div>
        <button id="btnPrev" class="secondary" disabled>Prev</button>
        <button id="btnNext" class="secondary" disabled>Next</button>
      </div>
      <table id="table">
        <thead>
          <tr>
            <th>Uploaded</th>
            <th>Path</th>
            <th>Size</th>
            <th>Open</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <footer>
    <small>Uses /api/list-logs, /api/export-logs, /api/prune-logs. Provide ADMIN_TOKEN if enabled.</small>
  </footer>

  <script src="./admin.js"></script>
 <script>
(async function () {
  // --- Helpers
  const $ = (sel, root=document) => root.querySelector(sel);
  const el = (tag, attrs={}, children=[]) => {
    const n = document.createElement(tag);
    for (const [k,v] of Object.entries(attrs)) {
      if (k === "class") n.className = v;
      else if (k === "html") n.innerHTML = v;
      else n.setAttribute(k, v);
    }
    const el = (tag, attrs = {}, children = []) => {
  const n = document.createElement(tag);

  for (const [k, v] of Object.entries(attrs || {})) {
    if (v == null) continue;
    if (k === "class") n.className = String(v);
    else if (k === "html") n.innerHTML = String(v);
    else n.setAttribute(k, String(v));
  }

  const add = (c) => {
    if (c == null || c === false) return;          // ignore null/undefined/false
    if (Array.isArray(c)) { c.forEach(add); return; } // allow nested arrays
    if (c instanceof Node) n.appendChild(c);       // Node OK
    else n.appendChild(document.createTextNode(String(c))); // numbers/booleans -> text
  };

  children.forEach(add);
  return n;
};

  const todayISO = () => new Date().toISOString().slice(0,10);

  const fmtMs = (ms) => {
    const s = Math.max(0, Math.round(ms/1000));
    if (s < 60) return `${s}s`;
    const m = Math.floor(s/60);
    const r = s % 60;
    return `${m}m ${r}s`;
  };

  function normalizeChoiceText(t) {
    return String(t || "")
      .replace(/\s+/g, " ")
      .trim()
      .slice(0, 220);
  }

  async function fetchJSON(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  function asArray(x) { return Array.isArray(x) ? x : []; }

  function humanScore(session) {
    // session: {events[], logs, types:Set, firstTs, lastTs, choiceClicks}
    const evs = session.events.slice().sort((a,b)=> (a.ts||0)-(b.ts||0));
    let maxGap = 0;
    for (let i=1; i<evs.length; i++) {
      const a = (evs[i-1]?.ts||0);
      const b = (evs[i]?.ts||0);
      const gap = b - a;
      if (gap > maxGap) maxGap = gap;
    }

    let score = 0;
    if (session.choiceClicks >= 1) score += 6;       // strongest signal
    if (session.types.size >= 2) score += 2;         // multiple event types
    if (session.logs >= 2) score += 1;               // multiple blobs → longer activity
    if (maxGap >= 800) score += 1;                   // human-like pause
    if (maxGap >= 2000) score += 1;

    // Penalize pure lifecycle noise
    const onlyLifecycle = (session.types.size === 1 && session.types.has("page_visibility"));
    if (onlyLifecycle) score -= 4;

    return { score, maxGap };
  }

  function bucket(score) {
    if (score >= 5) return { label: "Human", tone: "good" };
    if (score >= 2) return { label: "Maybe", tone: "mid" };
    return { label: "Noise", tone: "bad" };
  }

  // --- Mount UI near the top of <main>
  const main = document.querySelector("main") || document.body;

  const mount = el("section", {
    id: "topChoicesMount",
    style: "margin:16px 0; padding:14px; border:1px solid #1e293b; border-radius:14px; background:rgba(2,6,23,.35);"
  });

  // Insert before existing controls/results if possible
  const firstSection = main.querySelector("section");
  if (firstSection) main.insertBefore(mount, firstSection);
  else main.appendChild(mount);

  mount.appendChild(el("h2", { style:"margin:0 0 10px 0;" }, ["Playtest Insights"]));
  mount.appendChild(el("p", { style:"margin:0 0 14px 0; opacity:.8; font-size:13px;" }, [
    "Top choices + session drill-down (no backend). "
  ]));

  // Controls row
  const controls = el("div", { style:"display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:10px;" });

  const dateInput = el("input", { type:"date", value: todayISO(), style:"padding:6px 8px;" });
  const limitInput = el("input", { type:"number", value:"200", min:"1", max:"2000", style:"width:110px; padding:6px 8px;" });
  const onlyHumans = el("input", { type:"checkbox" });
  const runBtn = el("button", { type:"button", style:"padding:6px 10px; cursor:pointer;" }, ["Build"]);
  const status = el("div", { style:"font-size:12px; opacity:.85;" }, [""]);

  controls.appendChild(el("label", {}, ["Date: ", dateInput]));
  controls.appendChild(el("label", {}, ["Max logs: ", limitInput]));
  controls.appendChild(el("label", { style:"display:flex; gap:6px; align-items:center;" }, [onlyHumans, "Only humans"]));
  controls.appendChild(runBtn);
  controls.appendChild(status);
  mount.appendChild(controls);

  // Layout: left (top choices), right (sessions list + drilldown)
  const layout = el("div", { style:"display:grid; grid-template-columns: 1.2fr .9fr; gap:14px; align-items:start;" });
  mount.appendChild(layout);

  const left = el("div", { style:"min-width:0;" });
  const right = el("div", { style:"min-width:0;" });
  layout.appendChild(left);
  layout.appendChild(right);

  // Left: top choices
  left.appendChild(el("h3", { style:"margin:0 0 8px 0;" }, ["Top choices (date)"]));
  const topChoicesWrap = el("div", { style:"overflow:auto; max-height:64vh; border:1px solid #1e293b; border-radius:12px;" });
  left.appendChild(topChoicesWrap);

  // Right: sessions
  right.appendChild(el("h3", { style:"margin:0 0 8px 0;" }, ["Sessions"]));

  const sessionMetaBar = el("div", { style:"display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;" });
  const scenarioFilter = el("select", { style:"padding:6px 8px; max-width:260px;" }, [
    el("option", { value:"" }, ["All scenarios"])
  ]);
  sessionMetaBar.appendChild(el("label", {}, ["Scenario: ", scenarioFilter]));
  right.appendChild(sessionMetaBar);

  const sessionsWrap = el("div", { style:"border:1px solid #1e293b; border-radius:12px; overflow:auto; max-height:28vh;" });
  right.appendChild(sessionsWrap);

  right.appendChild(el("h3", { style:"margin:12px 0 8px 0;" }, ["Session drill-down"]));
  const drill = el("div", { style:"border:1px solid #1e293b; border-radius:12px; padding:10px; overflow:auto; max-height:34vh;" }, [
    el("div", { style:"opacity:.75; font-size:13px;" }, ["Click a SID to inspect."])
  ]);
  right.appendChild(drill);

  function renderTopChoices(countsMap) {
    topChoicesWrap.innerHTML = "";

    const sorted = [...countsMap.entries()].sort((a,b) => b[1]-a[1]).slice(0, 60);

    const table = el("table", { style:"width:100%; border-collapse:collapse; font-size:13px;" });
    table.appendChild(el("thead", {}, [el("tr", {}, [
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px; width:44px;" }, ["#"]),
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px;" }, ["Choice text"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:90px;" }, ["Clicks"])
    ])]));

    const tbody = el("tbody");
    sorted.forEach(([text, n], idx) => {
      tbody.appendChild(el("tr", {}, [
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; opacity:.9;" }, [String(idx+1)]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px;" }, [text]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [String(n)])
      ]));
    });

    table.appendChild(tbody);
    topChoicesWrap.appendChild(table);
  }

  function renderSessionsList(scoredSessions) {
    sessionsWrap.innerHTML = "";

    const table = el("table", { style:"width:100%; border-collapse:collapse; font-size:12px;" });
    table.appendChild(el("thead", {}, [el("tr", {}, [
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px;" }, ["SID"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:70px;" }, ["Score"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:70px;" }, ["Clicks"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:85px;" }, ["Dur."])
    ])]));

    const tbody = el("tbody");
    scoredSessions.slice(0, 200).forEach(s => {
      const b = bucket(s.score);
      const sidBtn = el("button", {
        type:"button",
        style:"border:none; background:none; color:inherit; padding:0; margin:0; cursor:pointer; text-align:left; font-family:monospace;"
      }, [s.sid]);

      sidBtn.addEventListener("click", () => showSession(s));

      const badge = el("span", {
        style: `display:inline-block; margin-left:8px; padding:2px 8px; border-radius:999px; font-size:11px; border:1px solid rgba(148,163,184,.35); opacity:.95;`
      }, [b.label]);

      const sidCell = el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px;" }, [sidBtn, badge]);

      tbody.appendChild(el("tr", {}, [
        sidCell,
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [String(s.score)]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [String(s.choiceClicks)]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [fmtMs(s.durationMs)])
      ]));
    });

    table.appendChild(tbody);
    sessionsWrap.appendChild(table);
  }

  function showSession(s) {
    // s has: sid, score, scenarioId (dominant), firstTs, lastTs, durationMs, choiceClicks, types, events, blobs[]
    drill.innerHTML = "";

    const b = bucket(s.score);

    drill.appendChild(el("div", { style:"display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:baseline;" }, [
      el("div", {}, [
        el("div", { style:"font-family:monospace; font-size:13px;" }, [`SID: ${s.sid}`]),
        el("div", { style:"opacity:.85; font-size:12px; margin-top:4px;" }, [
          `Score ${s.score} (${b.label}) · clicks ${s.choiceClicks} · duration ${fmtMs(s.durationMs)} · logs ${s.blobs.length}`
        ]),
        el("div", { style:"opacity:.75; font-size:12px; margin-top:4px;" }, [
          `Types: ${s.types.join(", ")}`
        ]),
        s.scenarioId ? el("div", { style:"opacity:.75; font-size:12px; margin-top:4px;" }, [
          `Scenario: ${s.scenarioId}`
        ]) : el("div")
      ]),
      el("div", {}, [
        el("button", { type:"button", style:"padding:6px 10px; cursor:pointer;" }, ["Copy SID"]).addEventListener("click", async () => {
          try { await navigator.clipboard.writeText(s.sid); } catch {}
        })
      ])
    ]));

    // Raw blob links
const links = el("div", {
  style: "margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;"
});

const MAX_LINKS = 6;

s.blobs.slice(0, MAX_LINKS).forEach((url, i) => {
  const a = el("a", {
    href: url,
    target: "_blank",
    rel: "noopener",
    style: "font-size:12px; opacity:.9; text-decoration:underline;"
  }, [`Open blob ${i + 1}`]);

  links.appendChild(a);
});

if (s.blobs.length > MAX_LINKS) {
  links.appendChild(
    el("span", {
      style: "font-size:12px; opacity:.65;"
    }, [`+${s.blobs.length - MAX_LINKS} more…`])
  );
}

drill.appendChild(links);

    // Top choices inside this session
    const sessionChoiceCounts = new Map();
    for (const ev of s.events) {
      if (ev?.type !== "choice_click") continue;
      const text =
        normalizeChoiceText(ev.text) ||
        normalizeChoiceText(ev.payload && ev.payload.text) ||
        normalizeChoiceText(ev.payload && ev.payload.label);
      if (!text) continue;
      sessionChoiceCounts.set(text, (sessionChoiceCounts.get(text)||0)+1);
    }

    drill.appendChild(el("h4", { style:"margin:12px 0 8px;" }, ["Session choices"]));
    if (sessionChoiceCounts.size === 0) {
      drill.appendChild(el("div", { style:"opacity:.75; font-size:12px;" }, ["No choice_click events in this session."]));
    } else {
      const top = [...sessionChoiceCounts.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 20);
      const ul = el("ul", { style:"margin:0; padding-left:18px; font-size:12px;" });
      for (const [t,n] of top) ul.appendChild(el("li", {}, [`${t} (${n})`]));
      drill.appendChild(ul);
    }

    // Timeline
    drill.appendChild(el("h4", { style:"margin:12px 0 8px;" }, ["Timeline"]));
    const evs = s.events.slice().sort((a,b)=> (a.ts||0)-(b.ts||0)).slice(0, 200);

    const tl = el("div", { style:"display:flex; flex-direction:column; gap:8px; font-size:12px;" });
    for (const ev of evs) {
      const ts = typeof ev.ts === "number" ? new Date(ev.ts).toLocaleTimeString() : "";
      const type = ev.type || "unknown";
      let desc = "";
      if (type === "scenario_loaded") {
        const sid = ev.payload?.value || ev.payload?.scenarioId || ev.value || "";
        desc = sid ? `→ ${sid}` : "";
      }
      if (type === "scenario_select") {
        const v = ev.payload?.value || "";
        const t = ev.payload?.text || "";
        desc = `→ ${v}${t ? ` (${t})` : ""}`;
      }
      if (type === "choice_click") {
        const t =
          normalizeChoiceText(ev.text) ||
          normalizeChoiceText(ev.payload && ev.payload.text) ||
          normalizeChoiceText(ev.payload && ev.payload.label);
        desc = t ? `→ ${t}` : "";
      }
      if (type === "page_visibility") {
        desc = `→ hidden=${String(ev.payload?.hidden)}`;
      }

      const row = el("div", { style:"border:1px solid rgba(30,41,59,.6); border-radius:10px; padding:8px 10px;" }, [
        el("div", { style:"opacity:.9;" }, [`${ts}  ${type}`]),
        desc ? el("div", { style:"opacity:.75; margin-top:4px;" }, [desc]) : el("div")
      ]);
      tl.appendChild(row);
    }
    drill.appendChild(tl);
  }

  async function build() {
    topChoicesWrap.innerHTML = "";
    sessionsWrap.innerHTML = "";
    drill.innerHTML = "";
    status.textContent = "Loading log list…";

    const date = dateInput.value || todayISO();
    const maxLogs = Math.max(1, Math.min(2000, Number(limitInput.value || 200)));

    const list = await fetchJSON(`/api/list-logs?date=${encodeURIComponent(date)}`);
    const items = asArray(list.items).slice(0, maxLogs);
    if (!items.length) {
      status.textContent = `No logs for ${date}.`;
      scenarioFilter.innerHTML = "";
      scenarioFilter.appendChild(el("option", { value:"" }, ["All scenarios"]));
      return;
    }

    status.textContent = `Fetching ${items.length} logs…`;

    // Top choices counts
    const counts = new Map();

    // Session aggregation
    const sessions = new Map(); // sid -> {sid, logs, blobs[], events[], types:Set, firstTs, lastTs, choiceClicks, scenarioCounts:Map }
    const scenarioSeen = new Set();

    let ok=0, failed=0;

    for (let i=0; i<items.length; i++) {
      const it = items[i];
      try {
        const j = await fetchJSON(it.url);

        const sid = j.sessionId || "unknown";
        if (!sessions.has(sid)) {
          sessions.set(sid, {
            sid,
            logs: 0,
            blobs: [],
            events: [],
            types: new Set(),
            firstTs: Infinity,
            lastTs: 0,
            choiceClicks: 0,
            scenarioCounts: new Map()
          });
        }
        const S = sessions.get(sid);
        S.logs++;
        S.blobs.push(it.url);

        const scenarioId = j.scenarioId || null;
        if (scenarioId) {
          scenarioSeen.add(scenarioId);
          S.scenarioCounts.set(scenarioId, (S.scenarioCounts.get(scenarioId)||0)+1);
        }

        const events = asArray(j.events);
        for (const ev of events) {
          if (!ev) continue;
          const ts = typeof ev.ts === "number" ? ev.ts : Date.now();
          S.firstTs = Math.min(S.firstTs, ts);
          S.lastTs = Math.max(S.lastTs, ts);
          if (ev.type) S.types.add(ev.type);
          S.events.push(ev);

          if (ev.type === "choice_click") {
            S.choiceClicks++;
            const text =
              normalizeChoiceText(ev.text) ||
              normalizeChoiceText(ev.payload && ev.payload.text) ||
              normalizeChoiceText(ev.payload && ev.payload.label);
            if (text) counts.set(text, (counts.get(text)||0)+1);
          }
        }

        ok++;
      } catch (e) {
        failed++;
      }

      if ((i+1) % 10 === 0 || i === items.length-1) {
        status.textContent = `Processed ${i+1}/${items.length} (ok ${ok}, failed ${failed})…`;
      }
    }

    // Populate scenario dropdown
    const currentScenario = scenarioFilter.value || "";
    scenarioFilter.innerHTML = "";
    scenarioFilter.appendChild(el("option", { value:"" }, ["All scenarios"]));
    [...scenarioSeen].sort().forEach(sid => scenarioFilter.appendChild(el("option", { value:sid }, [sid])));
    scenarioFilter.value = currentScenario;

    // Score sessions
    const scored = [...sessions.values()].map(S => {
      const { score } = humanScore(S);
      // dominant scenario for display
      let domScenario = null;
      let domN = 0;
      for (const [sid, n] of S.scenarioCounts.entries()) {
        if (n > domN) { domN = n; domScenario = sid; }
      }
      const first = Number.isFinite(S.firstTs) ? S.firstTs : 0;
      const last = S.lastTs || first;
      return {
        sid: S.sid,
        score,
        choiceClicks: S.choiceClicks,
        durationMs: Math.max(0, (last - first)),
        types: [...S.types],
        scenarioId: domScenario,
        events: S.events,
        blobs: S.blobs
      };
    }).sort((a,b)=> b.score - a.score);

    // Apply filters
    const scen = scenarioFilter.value || "";
    let filtered = scored;
    if (scen) filtered = filtered.filter(x => x.scenarioId === scen);
    if (onlyHumans.checked) filtered = filtered.filter(x => x.score >= 5);

    // Render
    status.textContent = `Done. choices=${counts.size} · sessions=${scored.length} (showing ${filtered.length})`;

    renderTopChoices(counts);
    renderSessionsList(filtered);

    // default drilldown: first human if exists
    const firstHuman = filtered.find(x => x.score >= 5) || filtered[0];
    if (firstHuman) showSession(firstHuman);
    else drill.innerHTML = `<div style="opacity:.75;font-size:13px;">No sessions to inspect under current filters.</div>`;
  }

  runBtn.addEventListener("click", () => build());
  scenarioFilter.addEventListener("change", () => build());
  onlyHumans.addEventListener("change", () => build());

  // auto-run once
  build().catch(err => {
    status.textContent = `Error: ${err.message || err}`;
  });
})();
</script>

 <script>
(async function () {
  // Drop-off view — no backend. Uses /api/list-logs + blob JSON.

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $ = (sel, root=document) => root.querySelector(sel);

  const el = (tag, attrs={}, children=[]) => {
    const n = document.createElement(tag);
    for (const [k,v] of Object.entries(attrs)) {
      if (k === "class") n.className = v;
      else if (k === "html") n.innerHTML = v;
      else n.setAttribute(k, v);
    }
    for (const c of children) n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    return n;
  };

  const todayISO = () => new Date().toISOString().slice(0,10);

  const norm = (t) => String(t || "").replace(/\s+/g," ").trim().slice(0,220);

  async function fetchJSON(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  // Try to reuse existing controls if present (from Playtest Insights block)
  function findSharedControls() {
    const mount = $("#topChoicesMount");
    if (!mount) return null;

    // first <input type="date"> and first <input type="number"> in that mount
    const dateInput = mount.querySelector('input[type="date"]');
    const maxInput  = mount.querySelector('input[type="number"]');
    const onlyHumans = mount.querySelector('input[type="checkbox"]'); // may exist
    const scenarioSelect = mount.querySelector('select'); // may exist
    return { mount, dateInput, maxInput, onlyHumans, scenarioSelect };
  }

  const shared = findSharedControls();

  // Mount UI
  const main = document.querySelector("main") || document.body;
  const host = shared?.mount || main;

  const wrap = el("section", {
    id: "dropoffMount",
    style: "margin:16px 0; padding:14px; border:1px solid #1e293b; border-radius:14px; background:rgba(2,6,23,.35);"
  });

  // Place it right under Playtest Insights if possible
  if (shared?.mount && shared.mount.parentElement) {
    shared.mount.parentElement.insertBefore(wrap, shared.mount.nextSibling);
  } else {
    main.appendChild(wrap);
  }

  wrap.appendChild(el("h3", { style:"margin:0 0 8px 0;" }, ["Drop-off (where people stop)"]));
  wrap.appendChild(el("p", { style:"margin:0 0 12px 0; opacity:.75; font-size:13px;" }, [
    "Aggregates last meaningful action per session (choice_click → scenario_loaded → last event)."
  ]));

  const controls = el("div", { style:"display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:10px;" });

  const dateInput = shared?.dateInput || el("input", { type:"date", value: todayISO(), style:"padding:6px 8px;" });
  const maxInput  = shared?.maxInput  || el("input", { type:"number", value:"200", min:"1", max:"2000", style:"width:110px; padding:6px 8px;" });

  const humansOnly = el("input", { type:"checkbox" });
  if (shared?.onlyHumans) humansOnly.checked = shared.onlyHumans.checked;

  const runBtn = el("button", { type:"button", style:"padding:6px 10px; cursor:pointer;" }, ["Build drop-off"]);
  const status = el("div", { style:"font-size:12px; opacity:.85;" }, [""]);

  controls.appendChild(el("label", {}, ["Date: ", dateInput]));
  controls.appendChild(el("label", {}, ["Max logs: ", maxInput]));
  controls.appendChild(el("label", { style:"display:flex; gap:6px; align-items:center;" }, [humansOnly, "Only humans"]));
  controls.appendChild(runBtn);
  controls.appendChild(status);

  wrap.appendChild(controls);

  const tableWrap = el("div", { style:"border:1px solid #1e293b; border-radius:12px; overflow:auto; max-height:58vh;" });
  wrap.appendChild(tableWrap);

  // Minimal “human score” (same philosophy as before, but simplified)
  function humanScoreFromSession(S) {
    const types = new Set(S.events.map(e => e?.type).filter(Boolean));
    const choiceClicks = S.events.filter(e => e?.type === "choice_click").length;

    let score = 0;
    if (choiceClicks >= 1) score += 6;
    if (types.size >= 2) score += 2;
    if (S.logs >= 2) score += 1;

    const onlyLifecycle = (types.size === 1 && types.has("page_visibility"));
    if (onlyLifecycle) score -= 4;

    return score;
  }

  function getDominantScenarioId(S) {
    const counts = new Map();
    if (S.scenarioId) counts.set(S.scenarioId, (counts.get(S.scenarioId)||0)+1);

    for (const ev of S.events) {
      if (ev?.type === "scenario_loaded") {
        const sid = ev.payload?.value || ev.payload?.scenarioId || ev.value || null;
        if (sid) counts.set(sid, (counts.get(sid)||0)+1);
      }
      if (ev?.scenarioId) counts.set(ev.scenarioId, (counts.get(ev.scenarioId)||0)+1);
    }

    let best = null, bestN = 0;
    for (const [k,n] of counts.entries()) {
      if (n > bestN) { bestN = n; best = k; }
    }
    return best;
  }

  function lastMeaningful(S) {
    const evs = [...S.events].filter(Boolean).sort((a,b)=> (a.ts||0)-(b.ts||0));
    const lastChoice = [...evs].reverse().find(e => e.type === "choice_click");
    if (lastChoice) {
      const text = norm(lastChoice.text) || norm(lastChoice.payload?.text) || norm(lastChoice.payload?.label);
      return { kind:"choice_click", text: text || "(choice_click)", ts:lastChoice.ts||0 };
    }

    const lastLoaded = [...evs].reverse().find(e => e.type === "scenario_loaded");
    if (lastLoaded) {
      const sid = lastLoaded.payload?.value || lastLoaded.payload?.scenarioId || lastLoaded.value || "";
      return { kind:"scenario_loaded", text: sid ? `scenario_loaded → ${sid}` : "scenario_loaded", ts:lastLoaded.ts||0 };
    }

    const lastAny = evs[evs.length-1];
    if (lastAny) return { kind:lastAny.type || "unknown", text:lastAny.type || "unknown", ts:lastAny.ts||0 };

    return { kind:"none", text:"(no events)", ts:0 };
  }

  function render(rows) {
    tableWrap.innerHTML = "";

    const table = el("table", { style:"width:100%; border-collapse:collapse; font-size:13px;" });
    table.appendChild(el("thead", {}, [el("tr", {}, [
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px; width:44px;" }, ["#"]),
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px; width:220px;" }, ["Scenario"]),
      el("th", { style:"text-align:left; border-bottom:1px solid #1e293b; padding:8px;" }, ["Drop-off at"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:90px;" }, ["Sessions"]),
      el("th", { style:"text-align:right; border-bottom:1px solid #1e293b; padding:8px; width:110px;" }, ["Avg dur."])
    ])]));

    const tbody = el("tbody");
    rows.forEach((r, idx) => {
      tbody.appendChild(el("tr", {}, [
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; opacity:.9;" }, [String(idx+1)]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; opacity:.95;" }, [r.scenario || "(unknown)"]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px;" }, [r.dropText]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [String(r.count)]),
        el("td", { style:"border-bottom:1px solid rgba(30,41,59,.5); padding:8px; text-align:right; font-variant-numeric:tabular-nums;" }, [r.avgDur])
      ]));
    });

    table.appendChild(tbody);
    tableWrap.appendChild(table);
  }

  function fmtDur(ms) {
    const s = Math.max(0, Math.round(ms/1000));
    const m = Math.floor(s/60);
    const r = s % 60;
    return m ? `${m}m ${r}s` : `${r}s`;
  }

  async function build() {
    status.textContent = "Loading…";
    tableWrap.innerHTML = "";

    const date = (dateInput.value || todayISO());
    const maxLogs = Math.max(1, Math.min(2000, Number(maxInput.value || 200)));

    const list = await fetchJSON(`/api/list-logs?date=${encodeURIComponent(date)}`);
    const items = (Array.isArray(list.items) ? list.items : []).slice(0, maxLogs);

    if (!items.length) {
      status.textContent = `No logs for ${date}.`;
      render([]);
      return;
    }

    status.textContent = `Fetching ${items.length} logs…`;

    // Aggregate per sessionId
    const sessions = new Map(); // sid -> {sid, logs, events[], firstTs, lastTs, scenarioId}
    let ok=0, failed=0;

    for (let i=0; i<items.length; i++) {
      const it = items[i];
      try {
        const j = await fetchJSON(it.url);
        const sid = j.sessionId || "unknown";
        if (!sessions.has(sid)) {
          sessions.set(sid, { sid, logs:0, events:[], firstTs:Infinity, lastTs:0, scenarioId:j.scenarioId||null });
        }
        const S = sessions.get(sid);
        S.logs++;
        if (!S.scenarioId && j.scenarioId) S.scenarioId = j.scenarioId;

        const evs = Array.isArray(j.events) ? j.events : [];
        for (const ev of evs) {
          if (!ev) continue;
          const ts = typeof ev.ts === "number" ? ev.ts : Date.now();
          S.firstTs = Math.min(S.firstTs, ts);
          S.lastTs = Math.max(S.lastTs, ts);
          S.events.push(ev);
        }

        ok++;
      } catch (e) {
        failed++;
      }

      if ((i+1) % 10 === 0 || i === items.length-1) {
        status.textContent = `Processed ${i+1}/${items.length} (ok ${ok}, failed ${failed})…`;
      }
    }

    // Build drop-off buckets
    const buckets = new Map(); // key -> {scenario, dropText, count, durSum}
    let sessionCount = 0;

    // optional scenario filter: reuse existing scenario dropdown from Playtest Insights if present
    const scenFilter = shared?.scenarioSelect?.value || "";

    for (const S of sessions.values()) {
      const score = humanScoreFromSession(S);
      if (humansOnly.checked && score < 5) continue;

      const scenario = getDominantScenarioId(S) || S.scenarioId || "(unknown)";
      if (scenFilter && scenario !== scenFilter) continue;

      const dur = (Number.isFinite(S.firstTs) ? (S.lastTs - S.firstTs) : 0);
      const last = lastMeaningful(S);

      const dropText = last.text || "(unknown)";
      const key = `${scenario}||${dropText}`;

      if (!buckets.has(key)) buckets.set(key, { scenario, dropText, count:0, durSum:0 });
      const B = buckets.get(key);
      B.count++;
      B.durSum += Math.max(0, dur);
      sessionCount++;
    }

    const rows = [...buckets.values()]
      .map(b => ({
        scenario: b.scenario,
        dropText: b.dropText,
        count: b.count,
        avgDur: fmtDur(b.durSum / Math.max(1, b.count))
      }))
      .sort((a,b) => b.count - a.count)
      .slice(0, 80);

    status.textContent = `Done. Sessions=${sessionCount}, unique drop-off points=${rows.length}.`;
    render(rows);
  }

  runBtn.addEventListener("click", () => build().catch(err => {
    status.textContent = `Error: ${err.message || err}`;
  }));

  // Auto-run once
  build().catch(err => {
    status.textContent = `Error: ${err.message || err}`;
  });
})();
</script>
 
</body>
</html>
